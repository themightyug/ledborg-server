/* Responder.c generated by valac 0.16.1, the Vala compiler
 * generated from Responder.vala, do not modify */

/*
 * Responder.vala
 * This file is part of LedBorg-Server
 *
 * Copyright (C) 2013 - Ross Taylor
 *
 * LedBorg-Server is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * LedBorg-Server is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with LedBorg-Server. If not, see <http://www.gnu.org/licenses/>.
 */

#include <glib.h>
#include <glib-object.h>
#include <libsoup/soup.h>
#include <stdlib.h>
#include <string.h>


#define LED_BORG_TYPE_RESPONDER (led_borg_responder_get_type ())
#define LED_BORG_RESPONDER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), LED_BORG_TYPE_RESPONDER, LedBorgResponder))
#define LED_BORG_RESPONDER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), LED_BORG_TYPE_RESPONDER, LedBorgResponderClass))
#define LED_BORG_IS_RESPONDER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), LED_BORG_TYPE_RESPONDER))
#define LED_BORG_IS_RESPONDER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), LED_BORG_TYPE_RESPONDER))
#define LED_BORG_RESPONDER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), LED_BORG_TYPE_RESPONDER, LedBorgResponderClass))

typedef struct _LedBorgResponder LedBorgResponder;
typedef struct _LedBorgResponderClass LedBorgResponderClass;
typedef struct _LedBorgResponderPrivate LedBorgResponderPrivate;

#define LED_BORG_TYPE_COLOUR (led_borg_colour_get_type ())
typedef struct _LedBorgColour LedBorgColour;
#define _g_free0(var) (var = (g_free (var), NULL))

struct _LedBorgResponder {
	GObject parent_instance;
	LedBorgResponderPrivate * priv;
};

struct _LedBorgResponderClass {
	GObjectClass parent_class;
};

struct _LedBorgColour {
	gint red;
	gint green;
	gint blue;
};


static gpointer led_borg_responder_parent_class = NULL;

GType led_borg_responder_get_type (void) G_GNUC_CONST;
enum  {
	LED_BORG_RESPONDER_DUMMY_PROPERTY
};
void led_borg_responder_respond_with_error (SoupMessage** msg, const gchar* error_message);
GType led_borg_colour_get_type (void) G_GNUC_CONST;
LedBorgColour* led_borg_colour_dup (const LedBorgColour* self);
void led_borg_colour_free (LedBorgColour* self);
void led_borg_responder_respond_with_colour (SoupMessage** msg, LedBorgColour* colour);
static gchar* led_borg_responder_generate_html_colour (LedBorgColour* colour);
gchar* led_borg_colour_get_ledborg_value (LedBorgColour *self);
gchar* led_borg_colour_get_html_value (LedBorgColour *self);
LedBorgResponder* led_borg_responder_new (void);
LedBorgResponder* led_borg_responder_construct (GType object_type);


static guint8* string_get_data (const gchar* self, int* result_length1) {
	guint8* result;
	guint8* res;
	gint res_length1;
	gint _res_size_;
	gint _tmp0_;
	gint _tmp1_;
	gint _tmp2_;
	guint8* _tmp3_;
	gint _tmp3__length1;
	guint8* _tmp4_;
	gint _tmp4__length1;
	g_return_val_if_fail (self != NULL, NULL);
	res = (guint8*) self;
	res_length1 = -1;
	_res_size_ = res_length1;
	_tmp0_ = strlen (self);
	_tmp1_ = _tmp0_;
	res_length1 = (gint) _tmp1_;
	_tmp2_ = res_length1;
	_tmp3_ = res;
	_tmp3__length1 = res_length1;
	_tmp4_ = _tmp3_;
	_tmp4__length1 = _tmp3__length1;
	if (result_length1) {
		*result_length1 = _tmp4__length1;
	}
	result = _tmp4_;
	return result;
}


void led_borg_responder_respond_with_error (SoupMessage** msg, const gchar* error_message) {
	SoupMessage* _tmp0_;
	const gchar* _tmp1_;
	SoupMessage* _tmp2_;
	const gchar* _tmp3_;
	guint8* _tmp4_;
	gint _tmp4__length1;
	guint8* _tmp5_;
	gint _tmp5__length1;
	g_return_if_fail (*msg != NULL);
	g_return_if_fail (error_message != NULL);
	_tmp0_ = *msg;
	_tmp1_ = error_message;
	soup_message_set_status_full (_tmp0_, (guint) SOUP_STATUS_INTERNAL_SERVER_ERROR, _tmp1_);
	_tmp2_ = *msg;
	_tmp3_ = error_message;
	_tmp4_ = string_get_data (_tmp3_, &_tmp4__length1);
	_tmp5_ = _tmp4_;
	_tmp5__length1 = _tmp4__length1;
	soup_message_set_response (_tmp2_, "text/plain", SOUP_MEMORY_COPY, _tmp5_, (gsize) _tmp5__length1);
}


void led_borg_responder_respond_with_colour (SoupMessage** msg, LedBorgColour* colour) {
	LedBorgColour _tmp0_;
	gchar* _tmp1_ = NULL;
	gchar* html;
	SoupMessage* _tmp2_;
	SoupMessageHeaders* _tmp3_;
	gchar* _tmp4_ = NULL;
	gchar* _tmp5_;
	SoupMessage* _tmp6_;
	SoupMessageHeaders* _tmp7_;
	gchar* _tmp8_ = NULL;
	gchar* _tmp9_;
	SoupMessage* _tmp10_;
	SoupMessage* _tmp11_;
	guint8* _tmp12_;
	gint _tmp12__length1;
	guint8* _tmp13_;
	gint _tmp13__length1;
	g_return_if_fail (*msg != NULL);
	g_return_if_fail (colour != NULL);
	_tmp0_ = *colour;
	_tmp1_ = led_borg_responder_generate_html_colour (&_tmp0_);
	html = _tmp1_;
	_tmp2_ = *msg;
	_tmp3_ = _tmp2_->response_headers;
	_tmp4_ = led_borg_colour_get_ledborg_value (colour);
	_tmp5_ = _tmp4_;
	soup_message_headers_append (_tmp3_, "Colour-LedBorg", _tmp5_);
	_g_free0 (_tmp5_);
	_tmp6_ = *msg;
	_tmp7_ = _tmp6_->response_headers;
	_tmp8_ = led_borg_colour_get_html_value (colour);
	_tmp9_ = _tmp8_;
	soup_message_headers_append (_tmp7_, "Colour-Html", _tmp9_);
	_g_free0 (_tmp9_);
	_tmp10_ = *msg;
	soup_message_set_status_full (_tmp10_, (guint) SOUP_STATUS_OK, "OK");
	_tmp11_ = *msg;
	_tmp12_ = string_get_data (html, &_tmp12__length1);
	_tmp13_ = _tmp12_;
	_tmp13__length1 = _tmp12__length1;
	soup_message_set_response (_tmp11_, "text/html", SOUP_MEMORY_COPY, _tmp13_, (gsize) _tmp13__length1);
	_g_free0 (html);
}


static gchar* led_borg_responder_generate_html_colour (LedBorgColour* colour) {
	gchar* result = NULL;
	gchar* _tmp0_ = NULL;
	gchar* _tmp1_;
	gchar* _tmp2_ = NULL;
	gchar* _tmp3_;
	gchar* html;
	g_return_val_if_fail (colour != NULL, NULL);
	_tmp0_ = led_borg_colour_get_html_value (colour);
	_tmp1_ = _tmp0_;
	_tmp2_ = g_strdup_printf ("\n" \
"\t\t\t\t<div style=\"width: 64px; height: 20px; border: black solid 8p" \
"x; background-color: %s;\">\n" \
"\t\t\t\t\t&nbsp;\n" \
"\t\t\t\t</div>\n" \
"\t\t\t", _tmp1_);
	_tmp3_ = _tmp2_;
	_g_free0 (_tmp1_);
	html = _tmp3_;
	result = html;
	return result;
}


LedBorgResponder* led_borg_responder_construct (GType object_type) {
	LedBorgResponder * self = NULL;
	self = (LedBorgResponder*) g_object_new (object_type, NULL);
	return self;
}


LedBorgResponder* led_borg_responder_new (void) {
	return led_borg_responder_construct (LED_BORG_TYPE_RESPONDER);
}


static void led_borg_responder_class_init (LedBorgResponderClass * klass) {
	led_borg_responder_parent_class = g_type_class_peek_parent (klass);
}


static void led_borg_responder_instance_init (LedBorgResponder * self) {
}


GType led_borg_responder_get_type (void) {
	static volatile gsize led_borg_responder_type_id__volatile = 0;
	if (g_once_init_enter (&led_borg_responder_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (LedBorgResponderClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) led_borg_responder_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (LedBorgResponder), 0, (GInstanceInitFunc) led_borg_responder_instance_init, NULL };
		GType led_borg_responder_type_id;
		led_borg_responder_type_id = g_type_register_static (G_TYPE_OBJECT, "LedBorgResponder", &g_define_type_info, 0);
		g_once_init_leave (&led_borg_responder_type_id__volatile, led_borg_responder_type_id);
	}
	return led_borg_responder_type_id__volatile;
}



