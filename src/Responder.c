/* Responder.c generated by valac 0.16.1, the Vala compiler
 * generated from Responder.vala, do not modify */

/*
 * Responder.vala
 * This file is part of LedBorg-Server
 *
 * Copyright (C) 2013 - Ross Taylor
 *
 * LedBorg-Server is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * LedBorg-Server is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with LedBorg-Server. If not, see <http://www.gnu.org/licenses/>.
 */

#include <glib.h>
#include <glib-object.h>
#include <libsoup/soup.h>
#include <stdlib.h>
#include <string.h>
#include <config.h>
#include <glib/gstdio.h>


#define LED_BORG_TYPE_RESPONDER (led_borg_responder_get_type ())
#define LED_BORG_RESPONDER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), LED_BORG_TYPE_RESPONDER, LedBorgResponder))
#define LED_BORG_RESPONDER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), LED_BORG_TYPE_RESPONDER, LedBorgResponderClass))
#define LED_BORG_IS_RESPONDER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), LED_BORG_TYPE_RESPONDER))
#define LED_BORG_IS_RESPONDER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), LED_BORG_TYPE_RESPONDER))
#define LED_BORG_RESPONDER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), LED_BORG_TYPE_RESPONDER, LedBorgResponderClass))

typedef struct _LedBorgResponder LedBorgResponder;
typedef struct _LedBorgResponderClass LedBorgResponderClass;
typedef struct _LedBorgResponderPrivate LedBorgResponderPrivate;

#define LED_BORG_TYPE_COLOUR (led_borg_colour_get_type ())
typedef struct _LedBorgColour LedBorgColour;
#define _g_free0(var) (var = (g_free (var), NULL))

struct _LedBorgResponder {
	GObject parent_instance;
	LedBorgResponderPrivate * priv;
};

struct _LedBorgResponderClass {
	GObjectClass parent_class;
};

struct _LedBorgColour {
	gint red;
	gint green;
	gint blue;
};


static gpointer led_borg_responder_parent_class = NULL;

GType led_borg_responder_get_type (void) G_GNUC_CONST;
enum  {
	LED_BORG_RESPONDER_DUMMY_PROPERTY
};
void led_borg_responder_respond_with_error (SoupMessage** msg, const gchar* error_message);
GType led_borg_colour_get_type (void) G_GNUC_CONST;
LedBorgColour* led_borg_colour_dup (const LedBorgColour* self);
void led_borg_colour_free (LedBorgColour* self);
void led_borg_responder_respond_with_colour (SoupMessage** msg, LedBorgColour* colour, gboolean include_form);
static gchar* led_borg_responder_generate_html_form (LedBorgColour* colour);
static gchar* led_borg_responder_generate_html_colour (LedBorgColour* colour);
gchar* led_borg_colour_get_ledborg_value (LedBorgColour *self);
gchar* led_borg_colour_get_html_value (LedBorgColour *self);
LedBorgResponder* led_borg_responder_new (void);
LedBorgResponder* led_borg_responder_construct (GType object_type);


static guint8* string_get_data (const gchar* self, int* result_length1) {
	guint8* result;
	guint8* res;
	gint res_length1;
	gint _res_size_;
	gint _tmp0_;
	gint _tmp1_;
	gint _tmp2_;
	guint8* _tmp3_;
	gint _tmp3__length1;
	guint8* _tmp4_;
	gint _tmp4__length1;
	g_return_val_if_fail (self != NULL, NULL);
	res = (guint8*) self;
	res_length1 = -1;
	_res_size_ = res_length1;
	_tmp0_ = strlen (self);
	_tmp1_ = _tmp0_;
	res_length1 = (gint) _tmp1_;
	_tmp2_ = res_length1;
	_tmp3_ = res;
	_tmp3__length1 = res_length1;
	_tmp4_ = _tmp3_;
	_tmp4__length1 = _tmp3__length1;
	if (result_length1) {
		*result_length1 = _tmp4__length1;
	}
	result = _tmp4_;
	return result;
}


void led_borg_responder_respond_with_error (SoupMessage** msg, const gchar* error_message) {
	SoupMessage* _tmp0_;
	const gchar* _tmp1_;
	SoupMessage* _tmp2_;
	const gchar* _tmp3_;
	guint8* _tmp4_;
	gint _tmp4__length1;
	guint8* _tmp5_;
	gint _tmp5__length1;
	g_return_if_fail (*msg != NULL);
	g_return_if_fail (error_message != NULL);
	_tmp0_ = *msg;
	_tmp1_ = error_message;
	soup_message_set_status_full (_tmp0_, (guint) SOUP_STATUS_INTERNAL_SERVER_ERROR, _tmp1_);
	_tmp2_ = *msg;
	_tmp3_ = error_message;
	_tmp4_ = string_get_data (_tmp3_, &_tmp4__length1);
	_tmp5_ = _tmp4_;
	_tmp5__length1 = _tmp4__length1;
	soup_message_set_response (_tmp2_, "text/plain", SOUP_MEMORY_COPY, _tmp5_, (gsize) _tmp5__length1);
}


void led_borg_responder_respond_with_colour (SoupMessage** msg, LedBorgColour* colour, gboolean include_form) {
	gchar* html = NULL;
	gboolean _tmp0_;
	SoupMessage* _tmp5_;
	SoupMessageHeaders* _tmp6_;
	gchar* _tmp7_ = NULL;
	gchar* _tmp8_;
	SoupMessage* _tmp9_;
	SoupMessageHeaders* _tmp10_;
	gchar* _tmp11_ = NULL;
	gchar* _tmp12_;
	SoupMessage* _tmp13_;
	SoupMessage* _tmp14_;
	const gchar* _tmp15_;
	guint8* _tmp16_;
	gint _tmp16__length1;
	guint8* _tmp17_;
	gint _tmp17__length1;
	g_return_if_fail (*msg != NULL);
	g_return_if_fail (colour != NULL);
	_tmp0_ = include_form;
	if (_tmp0_) {
		LedBorgColour _tmp1_;
		gchar* _tmp2_ = NULL;
		_tmp1_ = *colour;
		_tmp2_ = led_borg_responder_generate_html_form (&_tmp1_);
		_g_free0 (html);
		html = _tmp2_;
	} else {
		LedBorgColour _tmp3_;
		gchar* _tmp4_ = NULL;
		_tmp3_ = *colour;
		_tmp4_ = led_borg_responder_generate_html_colour (&_tmp3_);
		_g_free0 (html);
		html = _tmp4_;
	}
	_tmp5_ = *msg;
	_tmp6_ = _tmp5_->response_headers;
	_tmp7_ = led_borg_colour_get_ledborg_value (colour);
	_tmp8_ = _tmp7_;
	soup_message_headers_append (_tmp6_, "Colour-LedBorg", _tmp8_);
	_g_free0 (_tmp8_);
	_tmp9_ = *msg;
	_tmp10_ = _tmp9_->response_headers;
	_tmp11_ = led_borg_colour_get_html_value (colour);
	_tmp12_ = _tmp11_;
	soup_message_headers_append (_tmp10_, "Colour-Html", _tmp12_);
	_g_free0 (_tmp12_);
	_tmp13_ = *msg;
	soup_message_set_status_full (_tmp13_, (guint) SOUP_STATUS_OK, "OK");
	_tmp14_ = *msg;
	_tmp15_ = html;
	_tmp16_ = string_get_data (_tmp15_, &_tmp16__length1);
	_tmp17_ = _tmp16_;
	_tmp17__length1 = _tmp16__length1;
	soup_message_set_response (_tmp14_, "text/html", SOUP_MEMORY_COPY, _tmp17_, (gsize) _tmp17__length1);
	_g_free0 (html);
}


static gchar* led_borg_responder_generate_html_colour (LedBorgColour* colour) {
	gchar* result = NULL;
	gchar* _tmp0_ = NULL;
	gchar* _tmp1_;
	gchar* _tmp2_ = NULL;
	gchar* _tmp3_;
	gchar* html;
	g_return_val_if_fail (colour != NULL, NULL);
	_tmp0_ = led_borg_colour_get_html_value (colour);
	_tmp1_ = _tmp0_;
	_tmp2_ = g_strdup_printf ("\n" \
"\t\t\t\t<div style=\"width: 64px; height: 20px; border: black solid 8p" \
"x; background-color: %s;\">\n" \
"\t\t\t\t\t&nbsp;\n" \
"\t\t\t\t</div>\n" \
"\t\t\t", _tmp1_);
	_tmp3_ = _tmp2_;
	_g_free0 (_tmp1_);
	html = _tmp3_;
	result = html;
	return result;
}


static gchar* led_borg_responder_generate_html_form (LedBorgColour* colour) {
	gchar* result = NULL;
	gchar* html = NULL;
	gsize html_length = 0UL;
	gchar* _tmp0_ = NULL;
	gchar* html_file_path;
	gchar* _tmp1_ = NULL;
	gsize _tmp2_ = 0UL;
	const gchar* _tmp3_;
	LedBorgColour _tmp4_;
	gchar* _tmp5_ = NULL;
	gchar* _tmp6_;
	gchar* _tmp7_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (colour != NULL, NULL);
	_tmp0_ = g_strdup_printf ("%s/ledborg-server/ledborg-server.html", SYSCONFDIR);
	html_file_path = _tmp0_;
	g_file_get_contents (html_file_path, &_tmp1_, &_tmp2_, &_inner_error_);
	_g_free0 (html);
	html = _tmp1_;
	html_length = _tmp2_;
	if (_inner_error_ != NULL) {
		_g_free0 (html_file_path);
		_g_free0 (html);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	_tmp3_ = html;
	_tmp4_ = *colour;
	_tmp5_ = led_borg_responder_generate_html_colour (&_tmp4_);
	_tmp6_ = _tmp5_;
	_tmp7_ = g_strdup_printf (_tmp3_, _tmp6_);
	_g_free0 (html);
	html = _tmp7_;
	_g_free0 (_tmp6_);
	result = html;
	_g_free0 (html_file_path);
	return result;
}


LedBorgResponder* led_borg_responder_construct (GType object_type) {
	LedBorgResponder * self = NULL;
	self = (LedBorgResponder*) g_object_new (object_type, NULL);
	return self;
}


LedBorgResponder* led_borg_responder_new (void) {
	return led_borg_responder_construct (LED_BORG_TYPE_RESPONDER);
}


static void led_borg_responder_class_init (LedBorgResponderClass * klass) {
	led_borg_responder_parent_class = g_type_class_peek_parent (klass);
}


static void led_borg_responder_instance_init (LedBorgResponder * self) {
}


GType led_borg_responder_get_type (void) {
	static volatile gsize led_borg_responder_type_id__volatile = 0;
	if (g_once_init_enter (&led_borg_responder_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (LedBorgResponderClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) led_borg_responder_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (LedBorgResponder), 0, (GInstanceInitFunc) led_borg_responder_instance_init, NULL };
		GType led_borg_responder_type_id;
		led_borg_responder_type_id = g_type_register_static (G_TYPE_OBJECT, "LedBorgResponder", &g_define_type_info, 0);
		g_once_init_leave (&led_borg_responder_type_id__volatile, led_borg_responder_type_id);
	}
	return led_borg_responder_type_id__volatile;
}



